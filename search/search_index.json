{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Prism Magician \u00b6 What is the Magician? The Prism.Magician is a highly specialized development package that works with Prism for WPF, Uno Platform & Xamarin.Forms. With the growing set of Roslyn Analyzers and Code Fixes the Magician is the next best thing to pair programming with Dan & Brian in person. The Magician is contains a small class library with a number of various attributes that can be used at the Assembly, Class, Method or Property level. Depending on the attribute, the Magician will then use a Code Generation where possible, and IL weaving where necessary to help you write more efficient code. Who Can Use It? \u00b6 The Magician is NOT an open source library or available via NuGet.org. In order to use the Prism.Magician you must be one of the following: one of Dan's GitHub Sponsors a verified OSS Author / Maintainer have an active Enterprise Support contract with AvantiPoint The Magician is available on AvantiPoint's Customer Portal for Enterprise Support customers, and is available for all other consumers via the SponsorConnect portal. For those working with a team \u00b6 If you have a team of developers who require access you should either all be a GitHub Sponsor for proper legal access, or contact Dan through his company AvantiPoint for Enterprise access. Note that there are various options available for company licensing, some options include official support for Prism while other options may include access only to the Magician and other exclusive packages or tools. 3rd Party Support \u00b6 In addition to the Magician understanding how to work with WPF & Uno Platform the Magician also has some key integrations to support developers who may be working with: ReactiveUI Shiny Lib Microsoft.Extensions.DependencyInjection","title":"Home"},{"location":"#prism-magician","text":"What is the Magician? The Prism.Magician is a highly specialized development package that works with Prism for WPF, Uno Platform & Xamarin.Forms. With the growing set of Roslyn Analyzers and Code Fixes the Magician is the next best thing to pair programming with Dan & Brian in person. The Magician is contains a small class library with a number of various attributes that can be used at the Assembly, Class, Method or Property level. Depending on the attribute, the Magician will then use a Code Generation where possible, and IL weaving where necessary to help you write more efficient code.","title":"Prism Magician"},{"location":"#who-can-use-it","text":"The Magician is NOT an open source library or available via NuGet.org. In order to use the Prism.Magician you must be one of the following: one of Dan's GitHub Sponsors a verified OSS Author / Maintainer have an active Enterprise Support contract with AvantiPoint The Magician is available on AvantiPoint's Customer Portal for Enterprise Support customers, and is available for all other consumers via the SponsorConnect portal.","title":"Who Can Use It?"},{"location":"#for-those-working-with-a-team","text":"If you have a team of developers who require access you should either all be a GitHub Sponsor for proper legal access, or contact Dan through his company AvantiPoint for Enterprise access. Note that there are various options available for company licensing, some options include official support for Prism while other options may include access only to the Magician and other exclusive packages or tools.","title":"For those working with a team"},{"location":"#3rd-party-support","text":"In addition to the Magician understanding how to work with WPF & Uno Platform the Magician also has some key integrations to support developers who may be working with: ReactiveUI Shiny Lib Microsoft.Extensions.DependencyInjection","title":"3rd Party Support"},{"location":"codegen-vs-il-weaving/","text":"Code Generation vs IL Weaving \u00b6 This is perhaps an old debate of which is better Code Generation or IL Weaving? To be blunt, they are both great when used in the areas that they perform best. To start let's take something that you're probably already pretty familiar with: public partial class ViewA { public ViewA () { InitializeComponent (); } } You see this in every code behind class for your XAML Views, InitializeComponent(); ... but what is it and where did it come from? Simply put the InitializeComponent method is generated for you at build and handles loading the XAML View or the conversion between XAML and C# code. This is much the same as when you may provide an Element in XAML an x:Name=\"someName\" and then can access it via the generated someName property in your code behind. During design time builds it may appear that this is broken as the tasks to generate the code have not run or made the generated code available for intellisense. Now that we understand what Code Generation what exactly is IL Weaving? IL Weaving is a process which changes the assembly IL commands post compilation. Continuing with the above example let's say that we had something like: public partial class ViewA { public ViewA () { ViewModelLocator . SetAutowireViewModel ( this , true ); } } In this case we don't have a reference to InitializeComponent which will be generated, but we have our own code in place. With IL Weaving we are able to maintain a code base that looks like the above while achieving the following: public partial class ViewA { public ViewA () { InitializeComponent (); ViewModelLocator . SetAutowireViewModel ( this , true ); } } Benefits & Drawbacks \u00b6 There is a clear benefit here that our code can remain nice and clean as the InitializeComponent can be added into our existing code for us. However when debugging the debugger isn't going to be able to stop on the method invocation. On the flip side if we had a debug breakpoint in InitializeComponent, as generated code we could actively set breakpoints and step through our normal debugging process. How The Magician Uses these concepts \u00b6 The Magician primarily focuses on updating getters and setters for your properties while relying on Code Generation as much as possible. This means that you may have code like: [Bindable] public string Message { get ; set ; } Which the Magician will then turn into: private string _message ; public string Message { get => _message ; set => SetProperty ( ref _message , value ); } In this sample we use Code Generation to add the missing backing field while using IL Weaving to update the getter and setter.","title":"Code Gen vs IL Weaving"},{"location":"codegen-vs-il-weaving/#code-generation-vs-il-weaving","text":"This is perhaps an old debate of which is better Code Generation or IL Weaving? To be blunt, they are both great when used in the areas that they perform best. To start let's take something that you're probably already pretty familiar with: public partial class ViewA { public ViewA () { InitializeComponent (); } } You see this in every code behind class for your XAML Views, InitializeComponent(); ... but what is it and where did it come from? Simply put the InitializeComponent method is generated for you at build and handles loading the XAML View or the conversion between XAML and C# code. This is much the same as when you may provide an Element in XAML an x:Name=\"someName\" and then can access it via the generated someName property in your code behind. During design time builds it may appear that this is broken as the tasks to generate the code have not run or made the generated code available for intellisense. Now that we understand what Code Generation what exactly is IL Weaving? IL Weaving is a process which changes the assembly IL commands post compilation. Continuing with the above example let's say that we had something like: public partial class ViewA { public ViewA () { ViewModelLocator . SetAutowireViewModel ( this , true ); } } In this case we don't have a reference to InitializeComponent which will be generated, but we have our own code in place. With IL Weaving we are able to maintain a code base that looks like the above while achieving the following: public partial class ViewA { public ViewA () { InitializeComponent (); ViewModelLocator . SetAutowireViewModel ( this , true ); } }","title":"Code Generation vs IL Weaving"},{"location":"codegen-vs-il-weaving/#benefits-drawbacks","text":"There is a clear benefit here that our code can remain nice and clean as the InitializeComponent can be added into our existing code for us. However when debugging the debugger isn't going to be able to stop on the method invocation. On the flip side if we had a debug breakpoint in InitializeComponent, as generated code we could actively set breakpoints and step through our normal debugging process.","title":"Benefits &amp; Drawbacks"},{"location":"codegen-vs-il-weaving/#how-the-magician-uses-these-concepts","text":"The Magician primarily focuses on updating getters and setters for your properties while relying on Code Generation as much as possible. This means that you may have code like: [Bindable] public string Message { get ; set ; } Which the Magician will then turn into: private string _message ; public string Message { get => _message ; set => SetProperty ( ref _message , value ); } In this sample we use Code Generation to add the missing backing field while using IL Weaving to update the getter and setter.","title":"How The Magician Uses these concepts"},{"location":"connecting-to-the-feed/","text":"Connecting to the Feed \u00b6 Ok you're sold you want to use the Prism Magician... now what? This depends a little bit on whether you're a GitHub Sponsor or an Enterprise Support customer. GitHub Sponsors \u00b6 Sign into the Sponsor Connect portal. For this you will need to log in with your GitHub credentials. Note that the Sponsor Connect portal will request access to your private repos as it will require this for some upcoming functionality where you will be able to create projects and have them deployed to GitHub automatically. Enterprise Customers \u00b6 For Enterprise Customers you can access the Prism.Magician through the AvantiPoint NuGet feed. Note that access to the AvantiPoint customer portal requires a Microsoft Account. While it is avisable that you have an Azure Active Directory tenant backing your login such as Office 365, we can work with you to grant access on a case by case basis. Connecting to the NuGet Feed \u00b6 Once logged into the portal, you will see the connection information along with an area to create a key. Keys will remain valid for one year at which time you will need to generate a new key. Once you generate a key you will need to head over to Visual Studio and add the feed as a source. Note Both feeds require a username and password. For those connecting to Sponsor Connect you will use your GitHub username. For those connecting to the AvantiPoint Enterprise NuGet feed, you will use your full Microsoft work or personal email address that you used to login. Setting up the Feed in Visual Studio \u00b6 To add a package source in Visual Studio, you can click on: Tools -> Options Tools -> NuGet Package Manager -> Package Manager Settings Both will open the Options dialog, while the second one will bring you to the NuGet Package Manager group. Once there select the second option for the Package Sources: Click the Plus Icon in the upper right corner and you will get a new Package source that you can edit. Give it a name and add the source url from either the Sponsor Connect or AvantiPoint Portal. Click Update and then click Ok. Next open a project and select the new Package Feed as the source. It should prompt you for your username and a password which will be the token you created in the portal. Tip Visual Studio will add the Package Source credentials to the Windows Credential Manager. In the event that you need to update the token, open the Credential Manager, select Windows Credentials and then delete any entries for the nuget feed. You may see multiple entries including the feed domain in both the Windows Credentials and Generic Credentials, along with a VSCredentials_domainname Setting up the Feed in Visual Studio for Mac \u00b6 For Visual Studio Mac, click on the Visual Studio application name in the upper left of the toolbar and select Preferences from the dropdown menu. Scroll to the bottom and you will find the NuGet Sources. Click Add and the Add Package Source dialog will appear. Give it a name and the url from the portal. Now add your username in the username field and the token you created in the portal in the password field and click Add Source. Tip You can come back to the Sources any time to update the password Troubleshooting \u00b6 Some users have reported issues connecting to the package feed. In the event that you are unable to resolve the connection issues, it recommended that you configure the package source from the CLI. nuget sources Add -Name \"SponsorConnect\" -Source \"https://sponsorconnect.dev/v3/index.json\" -Username \"githubUsernameHere\" -Password \"sponsorConnectApiKeyHere\" -ValidAuthenticationTypes basic Tip The NuGet CLI is already part of the path as part of the Mono installation for Mac users. Windows users who have not made the NuGet CLI accessible in the path on their developer machine can download the latest version here .","title":"Connecting to the Feed"},{"location":"connecting-to-the-feed/#connecting-to-the-feed","text":"Ok you're sold you want to use the Prism Magician... now what? This depends a little bit on whether you're a GitHub Sponsor or an Enterprise Support customer.","title":"Connecting to the Feed"},{"location":"connecting-to-the-feed/#github-sponsors","text":"Sign into the Sponsor Connect portal. For this you will need to log in with your GitHub credentials. Note that the Sponsor Connect portal will request access to your private repos as it will require this for some upcoming functionality where you will be able to create projects and have them deployed to GitHub automatically.","title":"GitHub Sponsors"},{"location":"connecting-to-the-feed/#enterprise-customers","text":"For Enterprise Customers you can access the Prism.Magician through the AvantiPoint NuGet feed. Note that access to the AvantiPoint customer portal requires a Microsoft Account. While it is avisable that you have an Azure Active Directory tenant backing your login such as Office 365, we can work with you to grant access on a case by case basis.","title":"Enterprise Customers"},{"location":"connecting-to-the-feed/#connecting-to-the-nuget-feed","text":"Once logged into the portal, you will see the connection information along with an area to create a key. Keys will remain valid for one year at which time you will need to generate a new key. Once you generate a key you will need to head over to Visual Studio and add the feed as a source. Note Both feeds require a username and password. For those connecting to Sponsor Connect you will use your GitHub username. For those connecting to the AvantiPoint Enterprise NuGet feed, you will use your full Microsoft work or personal email address that you used to login.","title":"Connecting to the NuGet Feed"},{"location":"connecting-to-the-feed/#setting-up-the-feed-in-visual-studio","text":"To add a package source in Visual Studio, you can click on: Tools -> Options Tools -> NuGet Package Manager -> Package Manager Settings Both will open the Options dialog, while the second one will bring you to the NuGet Package Manager group. Once there select the second option for the Package Sources: Click the Plus Icon in the upper right corner and you will get a new Package source that you can edit. Give it a name and add the source url from either the Sponsor Connect or AvantiPoint Portal. Click Update and then click Ok. Next open a project and select the new Package Feed as the source. It should prompt you for your username and a password which will be the token you created in the portal. Tip Visual Studio will add the Package Source credentials to the Windows Credential Manager. In the event that you need to update the token, open the Credential Manager, select Windows Credentials and then delete any entries for the nuget feed. You may see multiple entries including the feed domain in both the Windows Credentials and Generic Credentials, along with a VSCredentials_domainname","title":"Setting up the Feed in Visual Studio"},{"location":"connecting-to-the-feed/#setting-up-the-feed-in-visual-studio-for-mac","text":"For Visual Studio Mac, click on the Visual Studio application name in the upper left of the toolbar and select Preferences from the dropdown menu. Scroll to the bottom and you will find the NuGet Sources. Click Add and the Add Package Source dialog will appear. Give it a name and the url from the portal. Now add your username in the username field and the token you created in the portal in the password field and click Add Source. Tip You can come back to the Sources any time to update the password","title":"Setting up the Feed in Visual Studio for Mac"},{"location":"connecting-to-the-feed/#troubleshooting","text":"Some users have reported issues connecting to the package feed. In the event that you are unable to resolve the connection issues, it recommended that you configure the package source from the CLI. nuget sources Add -Name \"SponsorConnect\" -Source \"https://sponsorconnect.dev/v3/index.json\" -Username \"githubUsernameHere\" -Password \"sponsorConnectApiKeyHere\" -ValidAuthenticationTypes basic Tip The NuGet CLI is already part of the path as part of the Mono installation for Mac users. Windows users who have not made the NuGet CLI accessible in the path on their developer machine can download the latest version here .","title":"Troubleshooting"},{"location":"enterprise/","text":"As Sponsorware the Magician is available only to GitHub Sponsors. It is freely available to use on an AS-IS basis by the Sponsor only. It may be used by the Sponsor on behalf of their company or client, however it may not be used by other developers. For those that require Enterprise access for development teams, the Magician is available through AvantiPoint. AvantiPoint offers both team access without support and team or individual access with support. For more information contact me via the AvantiPoint website or by email.","title":"Enterprise Access"},{"location":"getting-started/","text":"Ok so we know that the Magician works through a combination of Code Generation, IL Weaving, and providing Analyzers and Code Actions purpose built for Prism developers. But how exactly do you use the Magician? While there are certain things that the Magician may be able to infer about your intentions like you have a declared interface, but haven't implemented one or more methods, the Magician will often try to provide a default implementation for you. However most things that get generated for you will require you to let the Magician know that you want to do something. The Magician includes a very small library of Attributes that can be used throughout your application. These attributes help the Magician understand what your goals are. [ViewModelBase] public class ViewModelBase { } You probably will want a good ViewModelBase included in your application. The Magician will generate a customized ViewModelBase class for you and may infer certain things about your project while generating it. In the sample above we have provided the Magician the ViewModelBase attribute, but we haven't given it any properties or a base type. When generating the ViewModelBase it will evaluate our project to determine: Do we have a Forms, Wpf, or Uno project Do we have a reference to System.Reactive, ReactiveUI, or Shiny Lib In the event that we have a reference to ReactiveUI we will get a base class that inherits from ReactiveObject a base ViewModel that follows a more Reactive style of programming. However if we don't then it will instead use Prism's BindableBase. Next Steps \u00b6 Auto Initialization Automatic View Registration Dialogs Service Registration View Bindable/Dependency Props ViewModelBase","title":"Getting Started"},{"location":"getting-started/#next-steps","text":"Auto Initialization Automatic View Registration Dialogs Service Registration View Bindable/Dependency Props ViewModelBase","title":"Next Steps"},{"location":"analyzers/","text":"Magician Analyzers \u00b6 Perhaps one of the most powerful things you never knew you needed, and one of my all time favorite stories. Have you ever seen a resume where someone claimed to be an expert at Intellisense? We all rely on Intellisense to help us write better code and refactor code that could be a little better. Without a doubt Roslyn has made this a much better process for .NET Developers. The Magician ships with several Roslyn Analyzers to help power your Intellisense and light up some additional build warnings or errors to keep you on track. At this time the Analyzer suite is still in its infancy, and new analyzers and code refactoring will be introduced over time. Included Analyzers \u00b6 Application Lifecycle Analyzer Messaging Center Analyzer Dependency Service Analyzer NavigationResult Handling Analyzer Xamarin.Essentials Usage Analyzer Dependency Injection Anti-Pattern Analyzer Various Analyzers for improper use of Magician Attributes Planned Analyzers \u00b6 Unregistered Services Detect Additional Bad Coding Practices Detect Common Client Id's hard coded Detect Additional Bad Practices with Prism's Container Detect Invalid ViewModel names (i.e. ViewViewModel) Detect Direct INavigationService references when using the Generated ViewModelBase Will there be more? \u00b6 Yes there will be more analyzers planned and implemented over time. If you have an issue that has caused you problems in the past, be sure to reach out in the Magician channel in Discord and let me know.","title":"About"},{"location":"analyzers/#magician-analyzers","text":"Perhaps one of the most powerful things you never knew you needed, and one of my all time favorite stories. Have you ever seen a resume where someone claimed to be an expert at Intellisense? We all rely on Intellisense to help us write better code and refactor code that could be a little better. Without a doubt Roslyn has made this a much better process for .NET Developers. The Magician ships with several Roslyn Analyzers to help power your Intellisense and light up some additional build warnings or errors to keep you on track. At this time the Analyzer suite is still in its infancy, and new analyzers and code refactoring will be introduced over time.","title":"Magician Analyzers"},{"location":"analyzers/#included-analyzers","text":"Application Lifecycle Analyzer Messaging Center Analyzer Dependency Service Analyzer NavigationResult Handling Analyzer Xamarin.Essentials Usage Analyzer Dependency Injection Anti-Pattern Analyzer Various Analyzers for improper use of Magician Attributes","title":"Included Analyzers"},{"location":"analyzers/#planned-analyzers","text":"Unregistered Services Detect Additional Bad Coding Practices Detect Common Client Id's hard coded Detect Additional Bad Practices with Prism's Container Detect Invalid ViewModel names (i.e. ViewViewModel) Detect Direct INavigationService references when using the Generated ViewModelBase","title":"Planned Analyzers"},{"location":"analyzers/#will-there-be-more","text":"Yes there will be more analyzers planned and implemented over time. If you have an issue that has caused you problems in the past, be sure to reach out in the Magician channel in Discord and let me know.","title":"Will there be more?"},{"location":"code-gen/auto-initialization/","text":"Auto Initialization was a powerful feature previewed in Prism.Forms 7.2. There were a number of limitations though as this was ultimately powered by runtime Reflection, and of course was limited to only supporting Xamarin.Forms applications. How The Magician Does it Better! \u00b6 The Magician works at build time to generate the required Initialization and it doesn't care about whether you're working with a Forms, WPF, or Uno platform app.","title":"Auto Initialization"},{"location":"code-gen/auto-initialization/#how-the-magician-does-it-better","text":"The Magician works at build time to generate the required Initialization and it doesn't care about whether you're working with a Forms, WPF, or Uno platform app.","title":"How The Magician Does it Better!"},{"location":"code-gen/dialogs/","text":"","title":"Dialogs"},{"location":"code-gen/service-registration/","text":"","title":"Service Registration"},{"location":"code-gen/view-bindable-props/","text":"","title":"View Bindable/Dependency Props"},{"location":"code-gen/view-registration/","text":"Automatic View Registration couldn't be easier and has some distinct performance advantages over the built in Prism Automatic View registration for Prism.Forms. The Magician's Automatic View Registration: works on ALL platforms including WPF & Uno Platform bypasses runtime reflection with compile time generated code registers both the View & ViewModel extends the standard Prism ViewModelLocator defaults to find ViewModels with other common conventions ViewModel Location \u00b6 By Default Prism's ViewModel Locator convention looks for the ViewModel in the ViewModels namespace with a ViewModel suffix like: ViewA -> ViewAViewModel SomeView -> SomeViewModel The Magician is a little smarter where we will also look for SomePage -> SomeViewModel In addition to that the Magician will check in both the Views and ViewModel's namespaces incase you prefer to keep your ViewModel and View next to eachother in a more logical construct. What is a View \u00b6 This is actually a little more complex than you might think when it comes to automatic View discovery for Navigation. In the case of WPF or Uno platform, and in the event that you are using Regions for Prism.Forms your View is realistically dervived from a type that could make it a custom or composite control. As a result we only search within the Views and Pages namespaces. ! note The Magician will not register any View types that are abstract, and will automatically register the Xamarin.Forms TabbedPage & NavigationPage Customized View Naming \u00b6 This feature is still somewhat in flux as some additional functionality is planned, and how the Magician accomplishes custom view naming will be changing.","title":"Automatic View Registration"},{"location":"code-gen/view-registration/#viewmodel-location","text":"By Default Prism's ViewModel Locator convention looks for the ViewModel in the ViewModels namespace with a ViewModel suffix like: ViewA -> ViewAViewModel SomeView -> SomeViewModel The Magician is a little smarter where we will also look for SomePage -> SomeViewModel In addition to that the Magician will check in both the Views and ViewModel's namespaces incase you prefer to keep your ViewModel and View next to eachother in a more logical construct.","title":"ViewModel Location"},{"location":"code-gen/view-registration/#what-is-a-view","text":"This is actually a little more complex than you might think when it comes to automatic View discovery for Navigation. In the case of WPF or Uno platform, and in the event that you are using Regions for Prism.Forms your View is realistically dervived from a type that could make it a custom or composite control. As a result we only search within the Views and Pages namespaces. ! note The Magician will not register any View types that are abstract, and will automatically register the Xamarin.Forms TabbedPage & NavigationPage","title":"What is a View"},{"location":"code-gen/view-registration/#customized-view-naming","text":"This feature is still somewhat in flux as some additional functionality is planned, and how the Magician accomplishes custom view naming will be changing.","title":"Customized View Naming"},{"location":"code-gen/viewmodel-bindable-props/","text":"","title":"Viewmodel bindable props"},{"location":"code-gen/viewmodelbase/","text":"The Magician will help write you a complete base ViewModel customized to your current application references. This means that if you have a reference to System.Reactive through libraries like Shiny or ReactiveUI then it will automatically give you some reactive benefits like the Composite Disposible that will be called by IDestructible for you.","title":"ViewModelBase"},{"location":"code-gen/viewmodels/","text":"","title":"Viewmodels"}]}