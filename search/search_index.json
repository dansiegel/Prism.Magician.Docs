{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Prism Magician \u00b6 What is the Magician? The Prism.Magician is a highly specialized development package that works with Prism for WPF, Uno Platform & Xamarin.Forms. With the growing set of Roslyn Analyzers and Code Fixes the Magician is the next best thing to pair programming with Dan & Brian in person. The Magician is contains a small class library with a number of various attributes that can be used at the Assembly, Class, Method or Property level. Depending on the attribute, the Magician will then use a Code Generation where possible, and IL weaving where necessary to help you write more efficient code. Who Can Use It? \u00b6 The Magician is NOT an open source library or available via NuGet.org. In order to use the Prism.Magician you must be one of the following: one of Dan's GitHub Sponsors a verified OSS Author / Maintainer have an active Enterprise Support contract with AvantiPoint The Magician is available on AvantiPoint's Customer Portal for Enterprise Support customers, and is available for all other consumers via the SponsorConnect portal. For those working with a team \u00b6 If you have a team of developers who require access you should either all be a GitHub Sponsor for proper legal access, or contact Dan through his company AvantiPoint for Enterprise access. Note that there are various options available for company licensing, some options include official support for Prism while other options may include access only to the Magician and other exclusive packages or tools. 3rd Party Support \u00b6 In addition to the Magician understanding how to work with WPF & Uno Platform the Magician also has some key integrations to support developers who may be working with: ReactiveUI Shiny Lib Microsoft.Extensions.DependencyInjection","title":"Home"},{"location":"#prism-magician","text":"What is the Magician? The Prism.Magician is a highly specialized development package that works with Prism for WPF, Uno Platform & Xamarin.Forms. With the growing set of Roslyn Analyzers and Code Fixes the Magician is the next best thing to pair programming with Dan & Brian in person. The Magician is contains a small class library with a number of various attributes that can be used at the Assembly, Class, Method or Property level. Depending on the attribute, the Magician will then use a Code Generation where possible, and IL weaving where necessary to help you write more efficient code.","title":"Prism Magician"},{"location":"#who-can-use-it","text":"The Magician is NOT an open source library or available via NuGet.org. In order to use the Prism.Magician you must be one of the following: one of Dan's GitHub Sponsors a verified OSS Author / Maintainer have an active Enterprise Support contract with AvantiPoint The Magician is available on AvantiPoint's Customer Portal for Enterprise Support customers, and is available for all other consumers via the SponsorConnect portal.","title":"Who Can Use It?"},{"location":"#for-those-working-with-a-team","text":"If you have a team of developers who require access you should either all be a GitHub Sponsor for proper legal access, or contact Dan through his company AvantiPoint for Enterprise access. Note that there are various options available for company licensing, some options include official support for Prism while other options may include access only to the Magician and other exclusive packages or tools.","title":"For those working with a team"},{"location":"#3rd-party-support","text":"In addition to the Magician understanding how to work with WPF & Uno Platform the Magician also has some key integrations to support developers who may be working with: ReactiveUI Shiny Lib Microsoft.Extensions.DependencyInjection","title":"3rd Party Support"},{"location":"codegen-vs-il-weaving/","text":"Code Generation vs IL Weaving \u00b6 This is perhaps an old debate of which is better Code Generation or IL Weaving? To be blunt, they are both great when used in the areas that they perform best. To start let's take something that you're probably already pretty familiar with: public partial class ViewA { public ViewA () { InitializeComponent (); } } You see this in every code behind class for your XAML Views, InitializeComponent(); ... but what is it and where did it come from? Simply put the InitializeComponent method is generated for you at build and handles loading the XAML View or the conversion between XAML and C# code. This is much the same as when you may provide an Element in XAML an x:Name=\"someName\" and then can access it via the generated someName property in your code behind. During design time builds it may appear that this is broken as the tasks to generate the code have not run or made the generated code available for intellisense. Now that we understand what Code Generation what exactly is IL Weaving? IL Weaving is a process which changes the assembly IL commands post compilation. Continuing with the above example let's say that we had something like: public partial class ViewA { public ViewA () { ViewModelLocator . SetAutowireViewModel ( this , true ); } } In this case we don't have a reference to InitializeComponent which will be generated, but we have our own code in place. With IL Weaving we are able to maintain a code base that looks like the above while achieving the following: public partial class ViewA { public ViewA () { InitializeComponent (); ViewModelLocator . SetAutowireViewModel ( this , true ); } } Benefits & Drawbacks \u00b6 There is a clear benefit here that our code can remain nice and clean as the InitializeComponent can be added into our existing code for us. However when debugging the debugger isn't going to be able to stop on the method invocation. On the flip side if we had a debug breakpoint in InitializeComponent, as generated code we could actively set breakpoints and step through our normal debugging process. How The Magician Uses these concepts \u00b6 The Magician primarily focuses on updating getters and setters for your properties while relying on Code Generation as much as possible. This means that you may have code like: [Bindable] public string Message { get ; set ; } Which the Magician will then turn into: private string _message ; public string Message { get => _message ; set => SetProperty ( ref _message , value ); } In this sample we use Code Generation to add the missing backing field while using IL Weaving to update the getter and setter.","title":"Code Gen vs IL Weaving"},{"location":"codegen-vs-il-weaving/#code-generation-vs-il-weaving","text":"This is perhaps an old debate of which is better Code Generation or IL Weaving? To be blunt, they are both great when used in the areas that they perform best. To start let's take something that you're probably already pretty familiar with: public partial class ViewA { public ViewA () { InitializeComponent (); } } You see this in every code behind class for your XAML Views, InitializeComponent(); ... but what is it and where did it come from? Simply put the InitializeComponent method is generated for you at build and handles loading the XAML View or the conversion between XAML and C# code. This is much the same as when you may provide an Element in XAML an x:Name=\"someName\" and then can access it via the generated someName property in your code behind. During design time builds it may appear that this is broken as the tasks to generate the code have not run or made the generated code available for intellisense. Now that we understand what Code Generation what exactly is IL Weaving? IL Weaving is a process which changes the assembly IL commands post compilation. Continuing with the above example let's say that we had something like: public partial class ViewA { public ViewA () { ViewModelLocator . SetAutowireViewModel ( this , true ); } } In this case we don't have a reference to InitializeComponent which will be generated, but we have our own code in place. With IL Weaving we are able to maintain a code base that looks like the above while achieving the following: public partial class ViewA { public ViewA () { InitializeComponent (); ViewModelLocator . SetAutowireViewModel ( this , true ); } }","title":"Code Generation vs IL Weaving"},{"location":"codegen-vs-il-weaving/#benefits-drawbacks","text":"There is a clear benefit here that our code can remain nice and clean as the InitializeComponent can be added into our existing code for us. However when debugging the debugger isn't going to be able to stop on the method invocation. On the flip side if we had a debug breakpoint in InitializeComponent, as generated code we could actively set breakpoints and step through our normal debugging process.","title":"Benefits &amp; Drawbacks"},{"location":"codegen-vs-il-weaving/#how-the-magician-uses-these-concepts","text":"The Magician primarily focuses on updating getters and setters for your properties while relying on Code Generation as much as possible. This means that you may have code like: [Bindable] public string Message { get ; set ; } Which the Magician will then turn into: private string _message ; public string Message { get => _message ; set => SetProperty ( ref _message , value ); } In this sample we use Code Generation to add the missing backing field while using IL Weaving to update the getter and setter.","title":"How The Magician Uses these concepts"},{"location":"connecting-to-the-feed/","text":"Connecting to the Feed \u00b6 Ok you're sold you want to use the Prism Magician... now what? This depends a little bit on whether you're a GitHub Sponsor or an Enterprise Support customer. GitHub Sponsors \u00b6 Sign into the Sponsor Connect portal. For this you will need to log in with your GitHub credentials. Note that the Sponsor Connect portal will request access to your private repos as it will require this for some upcoming functionality where you will be able to create projects and have them deployed to GitHub automatically. Enterprise Customers \u00b6 For Enterprise Customers you can access the Prism.Magician through the AvantiPoint NuGet feed. Note that access to the AvantiPoint customer portal requires a Microsoft Account. While it is avisable that you have an Azure Active Directory tenant backing your login such as Office 365, we can work with you to grant access on a case by case basis. Connecting to the NuGet Feed \u00b6 Once logged into the portal, you will see the connection information along with an area to create a key. Keys will remain valid for one year at which time you will need to generate a new key. Once you generate a key you will need to head over to Visual Studio and add the feed as a source. Note Both feeds require a username and password. For those connecting to Sponsor Connect you will use your GitHub username. For those connecting to the AvantiPoint Enterprise NuGet feed, you will use your full Microsoft work or personal email address that you used to login. Setting up the Feed in Visual Studio \u00b6 To add a package source in Visual Studio, you can click on: Tools -> Options Tools -> NuGet Package Manager -> Package Manager Settings Both will open the Options dialog, while the second one will bring you to the NuGet Package Manager group. Once there select the second option for the Package Sources: Click the Plus Icon in the upper right corner and you will get a new Package source that you can edit. Give it a name and add the source url from either the Sponsor Connect or AvantiPoint Portal. Click Update and then click Ok. Next open a project and select the new Package Feed as the source. It should prompt you for your username and a password which will be the token you created in the portal. Tip Visual Studio will add the Package Source credentials to the Windows Credential Manager. In the event that you need to update the token, open the Credential Manager, select Windows Credentials and then delete any entries for the nuget feed. You may see multiple entries including the feed domain in both the Windows Credentials and Generic Credentials, along with a VSCredentials_domainname Setting up the Feed in Visual Studio for Mac \u00b6 For Visual Studio Mac, click on the Visual Studio application name in the upper left of the toolbar and select Preferences from the dropdown menu. Scroll to the bottom and you will find the NuGet Sources. Click Add and the Add Package Source dialog will appear. Give it a name and the url from the portal. Now add your username in the username field and the token you created in the portal in the password field and click Add Source. Tip You can come back to the Sources any time to update the password Troubleshooting \u00b6 Some users have reported issues connecting to the package feed. In the event that you are unable to resolve the connection issues, it recommended that you configure the package source from the CLI. nuget sources Add -Name \"SponsorConnect\" -Source \"https://sponsorconnect.dev/v3/index.json\" -Username \"githubUsernameHere\" -Password \"sponsorConnectApiKeyHere\" -ValidAuthenticationTypes basic Tip The NuGet CLI is already part of the path as part of the Mono installation for Mac users. Windows users who have not made the NuGet CLI accessible in the path on their developer machine can download the latest version here .","title":"Connecting to the Feed"},{"location":"connecting-to-the-feed/#connecting-to-the-feed","text":"Ok you're sold you want to use the Prism Magician... now what? This depends a little bit on whether you're a GitHub Sponsor or an Enterprise Support customer.","title":"Connecting to the Feed"},{"location":"connecting-to-the-feed/#github-sponsors","text":"Sign into the Sponsor Connect portal. For this you will need to log in with your GitHub credentials. Note that the Sponsor Connect portal will request access to your private repos as it will require this for some upcoming functionality where you will be able to create projects and have them deployed to GitHub automatically.","title":"GitHub Sponsors"},{"location":"connecting-to-the-feed/#enterprise-customers","text":"For Enterprise Customers you can access the Prism.Magician through the AvantiPoint NuGet feed. Note that access to the AvantiPoint customer portal requires a Microsoft Account. While it is avisable that you have an Azure Active Directory tenant backing your login such as Office 365, we can work with you to grant access on a case by case basis.","title":"Enterprise Customers"},{"location":"connecting-to-the-feed/#connecting-to-the-nuget-feed","text":"Once logged into the portal, you will see the connection information along with an area to create a key. Keys will remain valid for one year at which time you will need to generate a new key. Once you generate a key you will need to head over to Visual Studio and add the feed as a source. Note Both feeds require a username and password. For those connecting to Sponsor Connect you will use your GitHub username. For those connecting to the AvantiPoint Enterprise NuGet feed, you will use your full Microsoft work or personal email address that you used to login.","title":"Connecting to the NuGet Feed"},{"location":"connecting-to-the-feed/#setting-up-the-feed-in-visual-studio","text":"To add a package source in Visual Studio, you can click on: Tools -> Options Tools -> NuGet Package Manager -> Package Manager Settings Both will open the Options dialog, while the second one will bring you to the NuGet Package Manager group. Once there select the second option for the Package Sources: Click the Plus Icon in the upper right corner and you will get a new Package source that you can edit. Give it a name and add the source url from either the Sponsor Connect or AvantiPoint Portal. Click Update and then click Ok. Next open a project and select the new Package Feed as the source. It should prompt you for your username and a password which will be the token you created in the portal. Tip Visual Studio will add the Package Source credentials to the Windows Credential Manager. In the event that you need to update the token, open the Credential Manager, select Windows Credentials and then delete any entries for the nuget feed. You may see multiple entries including the feed domain in both the Windows Credentials and Generic Credentials, along with a VSCredentials_domainname","title":"Setting up the Feed in Visual Studio"},{"location":"connecting-to-the-feed/#setting-up-the-feed-in-visual-studio-for-mac","text":"For Visual Studio Mac, click on the Visual Studio application name in the upper left of the toolbar and select Preferences from the dropdown menu. Scroll to the bottom and you will find the NuGet Sources. Click Add and the Add Package Source dialog will appear. Give it a name and the url from the portal. Now add your username in the username field and the token you created in the portal in the password field and click Add Source. Tip You can come back to the Sources any time to update the password","title":"Setting up the Feed in Visual Studio for Mac"},{"location":"connecting-to-the-feed/#troubleshooting","text":"Some users have reported issues connecting to the package feed. In the event that you are unable to resolve the connection issues, it recommended that you configure the package source from the CLI. nuget sources Add -Name \"SponsorConnect\" -Source \"https://sponsorconnect.dev/v3/index.json\" -Username \"githubUsernameHere\" -Password \"sponsorConnectApiKeyHere\" -ValidAuthenticationTypes basic Tip The NuGet CLI is already part of the path as part of the Mono installation for Mac users. Windows users who have not made the NuGet CLI accessible in the path on their developer machine can download the latest version here .","title":"Troubleshooting"},{"location":"enterprise/","text":"As Sponsorware the Magician is available only to GitHub Sponsors. It is freely available to use on an AS-IS basis by the Sponsor only. It may be used by the Sponsor on behalf of their company or client, however it may not be used by other developers. For those that require Enterprise access for development teams, the Magician is available through AvantiPoint. AvantiPoint offers both team access without support and team or individual access with support. For more information contact me via the AvantiPoint website or by email.","title":"Enterprise Access"},{"location":"getting-started/","text":"Ok so we know that the Magician works through a combination of Code Generation, IL Weaving, and providing Analyzers and Code Actions purpose built for Prism developers. But how exactly do you use the Magician? While there are certain things that the Magician may be able to infer about your intentions like you have a declared interface, but haven't implemented one or more methods, the Magician will often try to provide a default implementation for you. However most things that get generated for you will require you to let the Magician know that you want to do something. The Magician includes a very small library of Attributes that can be used throughout your application. These attributes help the Magician understand what your goals are. [ViewModelBase] public class ViewModelBase { } You probably will want a good ViewModelBase included in your application. The Magician will generate a customized ViewModelBase class for you and may infer certain things about your project while generating it. In the sample above we have provided the Magician the ViewModelBase attribute, but we haven't given it any properties or a base type. When generating the ViewModelBase it will evaluate our project to determine: Do we have a Forms, Wpf, or Uno project Do we have a reference to System.Reactive, ReactiveUI, or Shiny Lib In the event that we have a reference to ReactiveUI we will get a base class that inherits from ReactiveObject a base ViewModel that follows a more Reactive style of programming. However if we don't then it will instead use Prism's BindableBase. Next Steps \u00b6 Auto Initialization Automatic View Registration Dialogs Service Registration View Bindable/Dependency Props ViewModelBase","title":"Getting Started"},{"location":"getting-started/#next-steps","text":"Auto Initialization Automatic View Registration Dialogs Service Registration View Bindable/Dependency Props ViewModelBase","title":"Next Steps"},{"location":"analyzers/","text":"Magician Analyzers \u00b6 Perhaps one of the most powerful things you never knew you needed, and one of my all time favorite stories. Have you ever seen a resume where someone claimed to be an expert at Intellisense? We all rely on Intellisense to help us write better code and refactor code that could be a little better. Without a doubt Roslyn has made this a much better process for .NET Developers. The Magician ships with several Roslyn Analyzers to help power your Intellisense and light up some additional build warnings or errors to keep you on track. At this time the Analyzer suite is still in its infancy, and new analyzers and code refactoring will be introduced over time. Included Analyzers \u00b6 Application Lifecycle Analyzer Messaging Center Analyzer Dependency Service Analyzer NavigationResult Handling Analyzer Xamarin.Essentials Usage Analyzer Dependency Injection Anti-Pattern Analyzer Various Analyzers for improper use of Magician Attributes Planned Analyzers \u00b6 Unregistered Services Detect Additional Bad Coding Practices Detect Common Client Id's hard coded Detect Additional Bad Practices with Prism's Container Detect Invalid ViewModel names (i.e. ViewViewModel) Detect Direct INavigationService references when using the Generated ViewModelBase Will there be more? \u00b6 Yes there will be more analyzers planned and implemented over time. If you have an issue that has caused you problems in the past, be sure to reach out in the Magician channel in Discord and let me know.","title":"About"},{"location":"analyzers/#magician-analyzers","text":"Perhaps one of the most powerful things you never knew you needed, and one of my all time favorite stories. Have you ever seen a resume where someone claimed to be an expert at Intellisense? We all rely on Intellisense to help us write better code and refactor code that could be a little better. Without a doubt Roslyn has made this a much better process for .NET Developers. The Magician ships with several Roslyn Analyzers to help power your Intellisense and light up some additional build warnings or errors to keep you on track. At this time the Analyzer suite is still in its infancy, and new analyzers and code refactoring will be introduced over time.","title":"Magician Analyzers"},{"location":"analyzers/#included-analyzers","text":"Application Lifecycle Analyzer Messaging Center Analyzer Dependency Service Analyzer NavigationResult Handling Analyzer Xamarin.Essentials Usage Analyzer Dependency Injection Anti-Pattern Analyzer Various Analyzers for improper use of Magician Attributes","title":"Included Analyzers"},{"location":"analyzers/#planned-analyzers","text":"Unregistered Services Detect Additional Bad Coding Practices Detect Common Client Id's hard coded Detect Additional Bad Practices with Prism's Container Detect Invalid ViewModel names (i.e. ViewViewModel) Detect Direct INavigationService references when using the Generated ViewModelBase","title":"Planned Analyzers"},{"location":"analyzers/#will-there-be-more","text":"Yes there will be more analyzers planned and implemented over time. If you have an issue that has caused you problems in the past, be sure to reach out in the Magician channel in Discord and let me know.","title":"Will there be more?"},{"location":"code-gen/auto-initialization/","text":"Auto Initialization was a powerful feature previewed in Prism.Forms 7.2. There were a number of limitations though as this was ultimately powered by runtime Reflection, and of course was limited to only supporting Xamarin.Forms applications. How The Magician Does it Better! \u00b6 The Magician works at build time to generate the required Initialization and it doesn't care about whether you're working with a Forms, WPF, or Uno platform app.","title":"Auto Initialization"},{"location":"code-gen/auto-initialization/#how-the-magician-does-it-better","text":"The Magician works at build time to generate the required Initialization and it doesn't care about whether you're working with a Forms, WPF, or Uno platform app.","title":"How The Magician Does it Better!"},{"location":"code-gen/dialogs/","text":"","title":"Dialogs"},{"location":"code-gen/service-registration/","text":"Service Registration can get really tedious. You have an interface definition, with one or more implementations. Maybe you need to register them in your Module or Application or perhaps you're using Shiny and need to register it in your Startup. The Magician uses a pattern similar to MEF in which a Registration attribute is added to the service implementation. There is an attribute matching each of Prism 8's registration APIs. For example let's say that we had the following services: public interface IBackendOptions { string Uri { get ; } string ClientId { get ; } } public interface IApiClient { // your API here... } We know that we'll be using these services in our app, typically we might have something like: protected override void RegisterTypes ( IContainerRegistry containerRegistry ) { containerRegistry . RegisterSingleton < IBackendOptions , BackendOptions >(); containerRegistry . Register < IApiClient , MyApiClient >(); } While you can continue to do that with services manually, with the Magician you can now instead decorate your service implementations like: [RegisterSingleton] public class BackendOptions : IBackendOptions { } [Register] public class MyApiClient : IApiClient { } As you might expect, the Magician will generate the code that you would have written above. This however helps to ensure that as you are working on your service implementation you will always be able to see at a glance that it is registered which additionally helps as other developers on your team work on the code later on. Note Scoped Services are currently not supported. If you have a good use case for why you really need a Scoped Service you should discuss this in Discord, and it could be added. At the current time, it's my belief that only in the case of the Prism INavigationService in Prism.Forms is there truly a good case for Scoped services in a Prism application. Multiple Interfaces \u00b6 There are times in which you may find yourself implementing multiple services. As example we may implement our IApiClient, and IDisposable on MyApiClient. We have no real way of knowing however whether you want MyApiClient to be registered for IApiClient or IDisposable. In this particular case you can specify the service type like: [Register(typeof(IApiClient))] public class MyApiClient : IApiClient , IDisposable { // your code here } Registering Multiple Services for a Single Implementation \u00b6 Sometimes you may find a need to have multiple smaller service definitions. As an example let's say that we're building an modular application. We might have an Authentication Module with an Authentication Service that handles getting the authentication token we will use to work with our API, and ultimately invalidating our session / token when the user signs out. We may however want to expose the Sign Out functionality in a common interface that can be shared between various modules in our application. In this case we might end up with something like: public interface IUserSessionService { Task SignOutAsync (); } public interface IAuthenticationService { Task < string > SignInAsync (); } public class AuthenticationService : IAuthenticationService , IUserSessionService { // your code here } In this case we can provide the AuthenticationService with the RegisterMany or RegisterManySingleton attribute depending on whether we expect a new instance or a single instance of the Authentication Service to be maintained. [RegisterManySingleton] public class AuthenticationService : IAuthenticationService , IUserSessionService { // your code here } Note When using RegisterManySingleton you will get a single instance of the Service implementation that will be used across all services. It will not be a single instance per service. Note If you have an interface such as IDisposable that should not be implemented be sure to pass the service types in the constructor of the attribute","title":"Service Registration"},{"location":"code-gen/service-registration/#multiple-interfaces","text":"There are times in which you may find yourself implementing multiple services. As example we may implement our IApiClient, and IDisposable on MyApiClient. We have no real way of knowing however whether you want MyApiClient to be registered for IApiClient or IDisposable. In this particular case you can specify the service type like: [Register(typeof(IApiClient))] public class MyApiClient : IApiClient , IDisposable { // your code here }","title":"Multiple Interfaces"},{"location":"code-gen/service-registration/#registering-multiple-services-for-a-single-implementation","text":"Sometimes you may find a need to have multiple smaller service definitions. As an example let's say that we're building an modular application. We might have an Authentication Module with an Authentication Service that handles getting the authentication token we will use to work with our API, and ultimately invalidating our session / token when the user signs out. We may however want to expose the Sign Out functionality in a common interface that can be shared between various modules in our application. In this case we might end up with something like: public interface IUserSessionService { Task SignOutAsync (); } public interface IAuthenticationService { Task < string > SignInAsync (); } public class AuthenticationService : IAuthenticationService , IUserSessionService { // your code here } In this case we can provide the AuthenticationService with the RegisterMany or RegisterManySingleton attribute depending on whether we expect a new instance or a single instance of the Authentication Service to be maintained. [RegisterManySingleton] public class AuthenticationService : IAuthenticationService , IUserSessionService { // your code here } Note When using RegisterManySingleton you will get a single instance of the Service implementation that will be used across all services. It will not be a single instance per service. Note If you have an interface such as IDisposable that should not be implemented be sure to pass the service types in the constructor of the attribute","title":"Registering Multiple Services for a Single Implementation"},{"location":"code-gen/view-bindable-props/","text":"Important This feature is still in preview as the IL Weaving piece has not yet been completed It's not at all uncommon when developing custom components to be working with the Application Framework's View types, and need to add a BindableProperty / DependencyProperty. These properties tend to be very verbose, not very type friendly, static, and a lot of typing. The Magician aims to make these tasks a little easier by allowing you to write convention based code that simplifies what your intent is. For this sample we'll look at a Xamarin.Forms Bindable Property, but WPF/Uno Platform Dependency Properties will work the same way. Let's say that you're building a reusable UserProfileComponent and it will have a FirstName and LastName property which will bind to different labels. What your real intent here is that you have two properties, so why clutter it up? public partial class UserProfileComponent : ContentView { [BindableProperty] public string FirstName { get ; set ; } [BindableProperty] public string LastName { get ; set ; } } Note When working with a WPF / Uno Platform project, use the DependencyProperty attribute instead. The BindableProperty attribute is ignored on those platforms and the DependencyProperty attribute is ignored in Xamarin.Forms projects. Important Always be sure to make any class partial when using the Magician otherwise it will fail the build when it generates additional code. The Magician will first CodeGen our BindableProperties like: public partial class UserProfileComponent : ContentView { public static readonly BindableProperty FirstNameProperty = BindableProperty . Create ( \"FirstName\" , typeof ( string ), typeof ( UserProfileComponent ), null ); public static readonly BindableProperty FirstNameProperty = BindableProperty . Create ( \"LastName\" , typeof ( string ), typeof ( UserProfileComponent ), null ); } Next the Magician will use IL weaving to change our getter and setter to: public partial class UserProfileComponent : ContentView { public string FirstName { get => ( string ) GetValue ( FirstNameProperty ); set => SetValue ( FirstNameProperty , value ); } } Warning The IL weaving feature is still not complete. Default Values \u00b6 When adding the BindableProperty or DependencyProperty attribute you can pass a default value in the constructor of the attribute. This value will be used as the default value in the generated BindableProperty or DependencyProperty. [BindableProperty(\"Dan\")] public string FirstName { get ; set ; } [BindableProperty(\"Siegel\")] public string LastName { get ; set ; } Handling events \u00b6 Handling Changed events with Bindable or Dependency Properties can be quite infuriating as you're working with the least common denominator rather than working with a strongly typed API. For example you may normally write a handler like: private static void OnFirstNameChanged ( BindableObject bindable , object oldValue , object newValue ) { // Your code here } With the Magician you have both flexibility and the ability to continue writing the same horrible method handlers, or you can write more intelligent handlers like: private static void OnFirstNameChanged ( UserProfileComponent component , string oldValue , string newValue ) { // Your code here } Granted that's better but still not really ideal in my opinion, so the Magician has you covered as you can also write your handlers like: private void OnFirstNameChanged ( string oldValue , string newValue ) { // Your code here } Or you can keep it really simple like: private void OnFirstNameChanged () { // Your code here } Customizing Event Handler Behavior \u00b6 Let's say that you have a 3rd property for the DisplayName and this will need to be updated whenever either the FirstName or LastName are updated. We can easily achieve this with the Magician: public partial class UserProfileComponent : ContentView { [BindableProperty] public string DisplayName { get ; set ; } [BindableProperty(onChanged: nameof(UpdateDisplayName))] public string FirstName { get ; set ; } [BindableProperty(onChanged: nameof(UpdateDisplayName))] public string LastName { get ; set ; } private void UpdateDisplayName () { string name = null ; if (! string . IsNullOrEmpty ( FirstName )) { name = FirstName ; if (! string . IsNullOrEmpty ( LastName )) { name += $ \" {LastName[0]}.\" ; } } else if (! string . IsNullOrEmpty ( LastName )) { name = $ \"Mr. {LastName}\" ; } DisplayName = name ; } }","title":"View Bindable/Dependency Props"},{"location":"code-gen/view-bindable-props/#default-values","text":"When adding the BindableProperty or DependencyProperty attribute you can pass a default value in the constructor of the attribute. This value will be used as the default value in the generated BindableProperty or DependencyProperty. [BindableProperty(\"Dan\")] public string FirstName { get ; set ; } [BindableProperty(\"Siegel\")] public string LastName { get ; set ; }","title":"Default Values"},{"location":"code-gen/view-bindable-props/#handling-events","text":"Handling Changed events with Bindable or Dependency Properties can be quite infuriating as you're working with the least common denominator rather than working with a strongly typed API. For example you may normally write a handler like: private static void OnFirstNameChanged ( BindableObject bindable , object oldValue , object newValue ) { // Your code here } With the Magician you have both flexibility and the ability to continue writing the same horrible method handlers, or you can write more intelligent handlers like: private static void OnFirstNameChanged ( UserProfileComponent component , string oldValue , string newValue ) { // Your code here } Granted that's better but still not really ideal in my opinion, so the Magician has you covered as you can also write your handlers like: private void OnFirstNameChanged ( string oldValue , string newValue ) { // Your code here } Or you can keep it really simple like: private void OnFirstNameChanged () { // Your code here }","title":"Handling events"},{"location":"code-gen/view-bindable-props/#customizing-event-handler-behavior","text":"Let's say that you have a 3rd property for the DisplayName and this will need to be updated whenever either the FirstName or LastName are updated. We can easily achieve this with the Magician: public partial class UserProfileComponent : ContentView { [BindableProperty] public string DisplayName { get ; set ; } [BindableProperty(onChanged: nameof(UpdateDisplayName))] public string FirstName { get ; set ; } [BindableProperty(onChanged: nameof(UpdateDisplayName))] public string LastName { get ; set ; } private void UpdateDisplayName () { string name = null ; if (! string . IsNullOrEmpty ( FirstName )) { name = FirstName ; if (! string . IsNullOrEmpty ( LastName )) { name += $ \" {LastName[0]}.\" ; } } else if (! string . IsNullOrEmpty ( LastName )) { name = $ \"Mr. {LastName}\" ; } DisplayName = name ; } }","title":"Customizing Event Handler Behavior"},{"location":"code-gen/view-registration/","text":"Automatic View Registration couldn't be easier and has some distinct performance advantages over the built in Prism Automatic View registration for Prism.Forms. The Magician's Automatic View Registration: works on ALL platforms including WPF & Uno Platform bypasses runtime reflection with compile time generated code registers both the View & ViewModel extends the standard Prism ViewModelLocator defaults to find ViewModels with other common conventions ViewModel Location \u00b6 By Default Prism's ViewModel Locator convention looks for the ViewModel in the ViewModels namespace with a ViewModel suffix like: ViewA -> ViewAViewModel SomeView -> SomeViewModel The Magician is a little smarter where we will also look for SomePage -> SomeViewModel In addition to that the Magician will check in both the Views and ViewModel's namespaces incase you prefer to keep your ViewModel and View next to eachother in a more logical construct. What is a View \u00b6 This is actually a little more complex than you might think when it comes to automatic View discovery for Navigation. In the case of WPF or Uno platform, and in the event that you are using Regions for Prism.Forms your View is realistically derived from a type that could make it a custom or composite control. As a result we only search within the Views and Pages namespaces. Note The Magician will not register any View types that are abstract, and will automatically register the Xamarin.Forms TabbedPage & NavigationPage Customized View Naming \u00b6 Warning This feature is still somewhat in flux as some additional functionality is planned, and how the Magician accomplishes custom view naming will be changing. Currently the Magician utilizes a service called the INameFormatProvider which will take an incoming View type and will return the View name. While this does provide a lot of flexibility it also creates some headaches when it comes to Modularity. In the event that you do nothing, All View names in Modules will end up just bing the View type name, however if a INameFormatProvider is registered it can alter the names of the Views in the application and modules. Let's assume that you have a View name like UserProfilePage . There are 4 common conventions that developers tend to use. UserProfilePage UserProfile userProfilePage userProfile Depending on your preference, in your application project add the NameFormatProvider attribute and pass in the preferred Style. If you do not do this your application will continue to use the default Type name. [assembly: NameFormatProvider(NameFormatProviderStyle.CamelCaseNoPageSuffix)]","title":"Automatic View Registration"},{"location":"code-gen/view-registration/#viewmodel-location","text":"By Default Prism's ViewModel Locator convention looks for the ViewModel in the ViewModels namespace with a ViewModel suffix like: ViewA -> ViewAViewModel SomeView -> SomeViewModel The Magician is a little smarter where we will also look for SomePage -> SomeViewModel In addition to that the Magician will check in both the Views and ViewModel's namespaces incase you prefer to keep your ViewModel and View next to eachother in a more logical construct.","title":"ViewModel Location"},{"location":"code-gen/view-registration/#what-is-a-view","text":"This is actually a little more complex than you might think when it comes to automatic View discovery for Navigation. In the case of WPF or Uno platform, and in the event that you are using Regions for Prism.Forms your View is realistically derived from a type that could make it a custom or composite control. As a result we only search within the Views and Pages namespaces. Note The Magician will not register any View types that are abstract, and will automatically register the Xamarin.Forms TabbedPage & NavigationPage","title":"What is a View"},{"location":"code-gen/view-registration/#customized-view-naming","text":"Warning This feature is still somewhat in flux as some additional functionality is planned, and how the Magician accomplishes custom view naming will be changing. Currently the Magician utilizes a service called the INameFormatProvider which will take an incoming View type and will return the View name. While this does provide a lot of flexibility it also creates some headaches when it comes to Modularity. In the event that you do nothing, All View names in Modules will end up just bing the View type name, however if a INameFormatProvider is registered it can alter the names of the Views in the application and modules. Let's assume that you have a View name like UserProfilePage . There are 4 common conventions that developers tend to use. UserProfilePage UserProfile userProfilePage userProfile Depending on your preference, in your application project add the NameFormatProvider attribute and pass in the preferred Style. If you do not do this your application will continue to use the default Type name. [assembly: NameFormatProvider(NameFormatProviderStyle.CamelCaseNoPageSuffix)]","title":"Customized View Naming"},{"location":"code-gen/viewmodel-bindable-props/","text":"","title":"Viewmodel bindable props"},{"location":"code-gen/viewmodelbase/","text":"The Magician will help write you a complete base ViewModel customized to your current application references. This means that if you have a reference to System.Reactive through libraries like Shiny or ReactiveUI then it will automatically give you some reactive benefits like the Composite Disposable that will be called by IDestructible for you.","title":"ViewModelBase"},{"location":"code-gen/viewmodels/","text":"","title":"Viewmodels"}]}