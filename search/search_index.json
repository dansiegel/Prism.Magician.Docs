{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Prism Magician \u00b6 What is the Magician? The Prism.Magician is a highly specialized development package that works with Prism for WPF, Uno Platform & Xamarin.Forms. With the growing set of Roslyn Analyzers and Code Fixes the Magician is the next best thing to pair programming with Dan & Brian in person. The Magician is contains a small class library with a number of various attributes that can be used at the Assembly, Class, Method or Property level. Depending on the attribute, the Magician will then use a Code Generation where possible, and IL weaving where necessary to help you write more efficient code. Who Can Use It? \u00b6 The Magician is NOT an open source library or available via NuGet.org. In order to use the Prism.Magician you must be one of the following: one of Dan's GitHub Sponsors a verified OSS Author / Maintainer have an active Enterprise Support contract with AvantiPoint The Magician is available on AvantiPoint's Customer Portal for Enterprise Support customers, and is available for all other consumers via the SponsorConnect portal. For those working with a team \u00b6 If you have a team of developers who require access you should either all be a GitHub Sponsor for proper legal access, or contact Dan through his company AvantiPoint for Enterprise access. Note that there are various options available for company licensing, some options include official support for Prism while other options may include access only to the Magician and other exclusive packages or tools. 3rd Party Support \u00b6 In addition to the Magician understanding how to work with WPF & Uno Platform the Magician also has some key integrations to support developers who may be working with: ReactiveUI Shiny Lib Microsoft.Extensions.DependencyInjection","title":"Home"},{"location":"#prism-magician","text":"What is the Magician? The Prism.Magician is a highly specialized development package that works with Prism for WPF, Uno Platform & Xamarin.Forms. With the growing set of Roslyn Analyzers and Code Fixes the Magician is the next best thing to pair programming with Dan & Brian in person. The Magician is contains a small class library with a number of various attributes that can be used at the Assembly, Class, Method or Property level. Depending on the attribute, the Magician will then use a Code Generation where possible, and IL weaving where necessary to help you write more efficient code.","title":"Prism Magician"},{"location":"#who-can-use-it","text":"The Magician is NOT an open source library or available via NuGet.org. In order to use the Prism.Magician you must be one of the following: one of Dan's GitHub Sponsors a verified OSS Author / Maintainer have an active Enterprise Support contract with AvantiPoint The Magician is available on AvantiPoint's Customer Portal for Enterprise Support customers, and is available for all other consumers via the SponsorConnect portal.","title":"Who Can Use It?"},{"location":"#for-those-working-with-a-team","text":"If you have a team of developers who require access you should either all be a GitHub Sponsor for proper legal access, or contact Dan through his company AvantiPoint for Enterprise access. Note that there are various options available for company licensing, some options include official support for Prism while other options may include access only to the Magician and other exclusive packages or tools.","title":"For those working with a team"},{"location":"#3rd-party-support","text":"In addition to the Magician understanding how to work with WPF & Uno Platform the Magician also has some key integrations to support developers who may be working with: ReactiveUI Shiny Lib Microsoft.Extensions.DependencyInjection","title":"3rd Party Support"},{"location":"codegen-vs-il-weaving/","text":"Code Generation vs IL Weaving \u00b6 This is perhaps an old debate of which is better Code Generation or IL Weaving? To be blunt, they are both great when used in the areas that they perform best. To start let's take something that you're probably already pretty familiar with: public partial class ViewA { public ViewA () { InitializeComponent (); } } You see this in every code behind class for your XAML Views, InitializeComponent(); ... but what is it and where did it come from? Simply put the InitializeComponent method is generated for you at build and handles loading the XAML View or the conversion between XAML and C# code. This is much the same as when you may provide an Element in XAML an x:Name=\"someName\" and then can access it via the generated someName property in your code behind. During design time builds it may appear that this is broken as the tasks to generate the code have not run or made the generated code available for intellisense. Now that we understand what Code Generation what exactly is IL Weaving? IL Weaving is a process which changes the assembly IL commands post compilation. Continuing with the above example let's say that we had something like: public partial class ViewA { public ViewA () { ViewModelLocator . SetAutowireViewModel ( this , true ); } } In this case we don't have a reference to InitializeComponent which will be generated, but we have our own code in place. With IL Weaving we are able to maintain a code base that looks like the above while achieving the following: public partial class ViewA { public ViewA () { InitializeComponent (); ViewModelLocator . SetAutowireViewModel ( this , true ); } } Benefits & Drawbacks \u00b6 There is a clear benefit here that our code can remain nice and clean as the InitializeComponent can be added into our existing code for us. However when debugging the debugger isn't going to be able to stop on the method invocation. On the flip side if we had a debug breakpoint in InitializeComponent, as generated code we could actively set breakpoints and step through our normal debugging process. Why is a Combination of CodeGen & IL Weaving Better? \u00b6 Many fans of CodeGen believe that is is superior and you never need IL Weaving. This is just patently false. Let's look at a common case. When working with an MVVM Architecture we rely heavily on INotifyPropertyChanged to notify the Binding engine that a value has changed and the View needs to update something. If we look at the full code that we need we will again see: private string _message ; public string Message { get => _message ; set => SetProperty ( ref _message , value ); } While this is indeed the code required, it is clunky and quickly creates code clutter making it harder to come back to the code and see what our real intent is. It's for this reason we want to use something that will modify the code we write so that we can write less and keep our code easier to read in full. So what does the CodeGen version of this look like? public class SomeViewModel : BindableBase { [Bindable] private string _message ; } This is indeed less to write, and while the attribute may help us decipher a little bit what is going on it's still a bit unclear since we're really expecting our XAML to be like: <Label Text= \"{Binding Message}\" /> Ultimately a private backing field is not at all part of our intent, it is part of an ends to our means. So how can this be better? Well, traditionally you might have used PropertyChanged.Fody in which you might have: public class SomeViewModel : BindableBase { public string Message { get ; set ; } } This is much better now we at least know where our public Message property came from, but our backing field doesn't actually exist in anything we can work with. This is where the Magician really shines with a partnership between CodeGen and IL Weaving. How The Magician Uses these concepts \u00b6 The Magician primarily focuses on updating getters and setters for your properties while relying on Code Generation as much as possible. This means that your code remains clean, yet readable and clear on it's intent. public class SomeViewModel : BindableBase { [Bindable] public string Message { get ; set ; } } Remember our real intent is to have a public property called Message which will be bindable for our View to consume. With this the Magician will use CodeGen to provide us our backing field, and IL Weaving to update the getter and setter resulting in the full code that we need to bind our properties in the View. public class SomeViewModel : BindableBase { private string _message ; public string Message { get => _message ; set => SetProperty ( ref _message , value ); } } Note For those using ReactiveUI with a base class of ReactiveObject, be sure to use the Reactive attribute.","title":"Code Gen vs IL Weaving"},{"location":"codegen-vs-il-weaving/#code-generation-vs-il-weaving","text":"This is perhaps an old debate of which is better Code Generation or IL Weaving? To be blunt, they are both great when used in the areas that they perform best. To start let's take something that you're probably already pretty familiar with: public partial class ViewA { public ViewA () { InitializeComponent (); } } You see this in every code behind class for your XAML Views, InitializeComponent(); ... but what is it and where did it come from? Simply put the InitializeComponent method is generated for you at build and handles loading the XAML View or the conversion between XAML and C# code. This is much the same as when you may provide an Element in XAML an x:Name=\"someName\" and then can access it via the generated someName property in your code behind. During design time builds it may appear that this is broken as the tasks to generate the code have not run or made the generated code available for intellisense. Now that we understand what Code Generation what exactly is IL Weaving? IL Weaving is a process which changes the assembly IL commands post compilation. Continuing with the above example let's say that we had something like: public partial class ViewA { public ViewA () { ViewModelLocator . SetAutowireViewModel ( this , true ); } } In this case we don't have a reference to InitializeComponent which will be generated, but we have our own code in place. With IL Weaving we are able to maintain a code base that looks like the above while achieving the following: public partial class ViewA { public ViewA () { InitializeComponent (); ViewModelLocator . SetAutowireViewModel ( this , true ); } }","title":"Code Generation vs IL Weaving"},{"location":"codegen-vs-il-weaving/#benefits-drawbacks","text":"There is a clear benefit here that our code can remain nice and clean as the InitializeComponent can be added into our existing code for us. However when debugging the debugger isn't going to be able to stop on the method invocation. On the flip side if we had a debug breakpoint in InitializeComponent, as generated code we could actively set breakpoints and step through our normal debugging process.","title":"Benefits &amp; Drawbacks"},{"location":"codegen-vs-il-weaving/#why-is-a-combination-of-codegen-il-weaving-better","text":"Many fans of CodeGen believe that is is superior and you never need IL Weaving. This is just patently false. Let's look at a common case. When working with an MVVM Architecture we rely heavily on INotifyPropertyChanged to notify the Binding engine that a value has changed and the View needs to update something. If we look at the full code that we need we will again see: private string _message ; public string Message { get => _message ; set => SetProperty ( ref _message , value ); } While this is indeed the code required, it is clunky and quickly creates code clutter making it harder to come back to the code and see what our real intent is. It's for this reason we want to use something that will modify the code we write so that we can write less and keep our code easier to read in full. So what does the CodeGen version of this look like? public class SomeViewModel : BindableBase { [Bindable] private string _message ; } This is indeed less to write, and while the attribute may help us decipher a little bit what is going on it's still a bit unclear since we're really expecting our XAML to be like: <Label Text= \"{Binding Message}\" /> Ultimately a private backing field is not at all part of our intent, it is part of an ends to our means. So how can this be better? Well, traditionally you might have used PropertyChanged.Fody in which you might have: public class SomeViewModel : BindableBase { public string Message { get ; set ; } } This is much better now we at least know where our public Message property came from, but our backing field doesn't actually exist in anything we can work with. This is where the Magician really shines with a partnership between CodeGen and IL Weaving.","title":"Why is a Combination of CodeGen &amp; IL Weaving Better?"},{"location":"codegen-vs-il-weaving/#how-the-magician-uses-these-concepts","text":"The Magician primarily focuses on updating getters and setters for your properties while relying on Code Generation as much as possible. This means that your code remains clean, yet readable and clear on it's intent. public class SomeViewModel : BindableBase { [Bindable] public string Message { get ; set ; } } Remember our real intent is to have a public property called Message which will be bindable for our View to consume. With this the Magician will use CodeGen to provide us our backing field, and IL Weaving to update the getter and setter resulting in the full code that we need to bind our properties in the View. public class SomeViewModel : BindableBase { private string _message ; public string Message { get => _message ; set => SetProperty ( ref _message , value ); } } Note For those using ReactiveUI with a base class of ReactiveObject, be sure to use the Reactive attribute.","title":"How The Magician Uses these concepts"},{"location":"connecting-to-the-feed/","text":"Connecting to the Feed \u00b6 Ok you're sold you want to use the Prism Magician... now what? This depends a little bit on whether you're a GitHub Sponsor or an Enterprise Support customer. GitHub Sponsors \u00b6 Sign into the Sponsor Connect portal. For this you will need to log in with your GitHub credentials. Note that the Sponsor Connect portal will request access to your private repos as it will require this for some upcoming functionality where you will be able to create projects and have them deployed to GitHub automatically. Enterprise Customers \u00b6 For Enterprise Customers you can access the Prism.Magician through the AvantiPoint NuGet feed. Note that access to the AvantiPoint customer portal requires a Microsoft Account. While it is avisable that you have an Azure Active Directory tenant backing your login such as Office 365, we can work with you to grant access on a case by case basis. Connecting to the NuGet Feed \u00b6 Once logged into the portal, you will see the connection information along with an area to create a key. Keys will remain valid for one year at which time you will need to generate a new key. Once you generate a key you will need to head over to Visual Studio and add the feed as a source. Note Both feeds require a username and password. For those connecting to Sponsor Connect you will use your GitHub username. For those connecting to the AvantiPoint Enterprise NuGet feed, you will use your full Microsoft work or personal email address that you used to login. Setting up the Feed in Visual Studio \u00b6 To add a package source in Visual Studio, you can click on: Tools -> Options Tools -> NuGet Package Manager -> Package Manager Settings Both will open the Options dialog, while the second one will bring you to the NuGet Package Manager group. Once there select the second option for the Package Sources: Click the Plus Icon in the upper right corner and you will get a new Package source that you can edit. Give it a name and add the source url from either the Sponsor Connect or AvantiPoint Portal. Click Update and then click Ok. Next open a project and select the new Package Feed as the source. It should prompt you for your username and a password which will be the token you created in the portal. Tip Visual Studio will add the Package Source credentials to the Windows Credential Manager. In the event that you need to update the token, open the Credential Manager, select Windows Credentials and then delete any entries for the nuget feed. You may see multiple entries including the feed domain in both the Windows Credentials and Generic Credentials, along with a VSCredentials_domainname Setting up the Feed in Visual Studio for Mac \u00b6 For Visual Studio Mac, click on the Visual Studio application name in the upper left of the toolbar and select Preferences from the dropdown menu. Scroll to the bottom and you will find the NuGet Sources. Click Add and the Add Package Source dialog will appear. Give it a name and the url from the portal. Now add your username in the username field and the token you created in the portal in the password field and click Add Source. Tip You can come back to the Sources any time to update the password Troubleshooting \u00b6 Some users have reported issues connecting to the package feed. In the event that you are unable to resolve the connection issues, it recommended that you configure the package source from the CLI. nuget sources Add -Name \"SponsorConnect\" -Source \"https://sponsorconnect.dev/v3/index.json\" -Username \"githubUsernameHere\" -Password \"sponsorConnectApiKeyHere\" -ValidAuthenticationTypes basic Tip The NuGet CLI is already part of the path as part of the Mono installation for Mac users. Windows users who have not made the NuGet CLI accessible in the path on their developer machine can download the latest version here .","title":"Connecting to the Feed"},{"location":"connecting-to-the-feed/#connecting-to-the-feed","text":"Ok you're sold you want to use the Prism Magician... now what? This depends a little bit on whether you're a GitHub Sponsor or an Enterprise Support customer.","title":"Connecting to the Feed"},{"location":"connecting-to-the-feed/#github-sponsors","text":"Sign into the Sponsor Connect portal. For this you will need to log in with your GitHub credentials. Note that the Sponsor Connect portal will request access to your private repos as it will require this for some upcoming functionality where you will be able to create projects and have them deployed to GitHub automatically.","title":"GitHub Sponsors"},{"location":"connecting-to-the-feed/#enterprise-customers","text":"For Enterprise Customers you can access the Prism.Magician through the AvantiPoint NuGet feed. Note that access to the AvantiPoint customer portal requires a Microsoft Account. While it is avisable that you have an Azure Active Directory tenant backing your login such as Office 365, we can work with you to grant access on a case by case basis.","title":"Enterprise Customers"},{"location":"connecting-to-the-feed/#connecting-to-the-nuget-feed","text":"Once logged into the portal, you will see the connection information along with an area to create a key. Keys will remain valid for one year at which time you will need to generate a new key. Once you generate a key you will need to head over to Visual Studio and add the feed as a source. Note Both feeds require a username and password. For those connecting to Sponsor Connect you will use your GitHub username. For those connecting to the AvantiPoint Enterprise NuGet feed, you will use your full Microsoft work or personal email address that you used to login.","title":"Connecting to the NuGet Feed"},{"location":"connecting-to-the-feed/#setting-up-the-feed-in-visual-studio","text":"To add a package source in Visual Studio, you can click on: Tools -> Options Tools -> NuGet Package Manager -> Package Manager Settings Both will open the Options dialog, while the second one will bring you to the NuGet Package Manager group. Once there select the second option for the Package Sources: Click the Plus Icon in the upper right corner and you will get a new Package source that you can edit. Give it a name and add the source url from either the Sponsor Connect or AvantiPoint Portal. Click Update and then click Ok. Next open a project and select the new Package Feed as the source. It should prompt you for your username and a password which will be the token you created in the portal. Tip Visual Studio will add the Package Source credentials to the Windows Credential Manager. In the event that you need to update the token, open the Credential Manager, select Windows Credentials and then delete any entries for the nuget feed. You may see multiple entries including the feed domain in both the Windows Credentials and Generic Credentials, along with a VSCredentials_domainname","title":"Setting up the Feed in Visual Studio"},{"location":"connecting-to-the-feed/#setting-up-the-feed-in-visual-studio-for-mac","text":"For Visual Studio Mac, click on the Visual Studio application name in the upper left of the toolbar and select Preferences from the dropdown menu. Scroll to the bottom and you will find the NuGet Sources. Click Add and the Add Package Source dialog will appear. Give it a name and the url from the portal. Now add your username in the username field and the token you created in the portal in the password field and click Add Source. Tip You can come back to the Sources any time to update the password","title":"Setting up the Feed in Visual Studio for Mac"},{"location":"connecting-to-the-feed/#troubleshooting","text":"Some users have reported issues connecting to the package feed. In the event that you are unable to resolve the connection issues, it recommended that you configure the package source from the CLI. nuget sources Add -Name \"SponsorConnect\" -Source \"https://sponsorconnect.dev/v3/index.json\" -Username \"githubUsernameHere\" -Password \"sponsorConnectApiKeyHere\" -ValidAuthenticationTypes basic Tip The NuGet CLI is already part of the path as part of the Mono installation for Mac users. Windows users who have not made the NuGet CLI accessible in the path on their developer machine can download the latest version here .","title":"Troubleshooting"},{"location":"enterprise/","text":"As Sponsorware the Magician is available only to GitHub Sponsors. It is freely available to use on an AS-IS basis by the Sponsor only. It may be used by the Sponsor on behalf of their company or client, however it may not be used by other developers. For those that require Enterprise access for development teams, the Magician is available through AvantiPoint. AvantiPoint offers both team access without support and team or individual access with support. For more information contact me via the AvantiPoint website or by email.","title":"Enterprise Access"},{"location":"getting-started/","text":"Ok so we know that the Magician works through a combination of Code Generation, IL Weaving, and providing Analyzers and Code Actions purpose built for Prism developers. But how exactly do you use the Magician? While there are certain things that the Magician may be able to infer about your intentions like you have a declared interface, but haven't implemented one or more methods, the Magician will often try to provide a default implementation for you. However most things that get generated for you will require you to let the Magician know that you want to do something. The Magician includes a very small library of Attributes that can be used throughout your application. These attributes help the Magician understand what your goals are. [ViewModelBase] public class ViewModelBase { } You probably will want a good ViewModelBase included in your application. The Magician will generate a customized ViewModelBase class for you and may infer certain things about your project while generating it. In the sample above we have provided the Magician the ViewModelBase attribute, but we haven't given it any properties or a base type. When generating the ViewModelBase it will evaluate our project to determine: Do we have a Forms, Wpf, or Uno project Do we have a reference to System.Reactive, ReactiveUI, or Shiny Lib In the event that we have a reference to ReactiveUI we will get a base class that inherits from ReactiveObject a base ViewModel that follows a more Reactive style of programming. However if we don't then it will instead use Prism's BindableBase. Next Steps \u00b6 Auto Initialization Automatic View Registration Dialogs Service Registration View Bindable/Dependency Props ViewModelBase","title":"Getting Started"},{"location":"getting-started/#next-steps","text":"Auto Initialization Automatic View Registration Dialogs Service Registration View Bindable/Dependency Props ViewModelBase","title":"Next Steps"},{"location":"analyzers/","text":"Magician Analyzers \u00b6 Perhaps one of the most powerful things you never knew you needed, and one of my all time favorite stories. Have you ever seen a resume where someone claimed to be an expert at Intellisense? We all rely on Intellisense to help us write better code and refactor code that could be a little better. Without a doubt Roslyn has made this a much better process for .NET Developers. The Magician ships with several Roslyn Analyzers to help power your Intellisense and light up some additional build warnings or errors to keep you on track. At this time the Analyzer suite is still in its infancy, and new analyzers and code refactoring will be introduced over time. Included Analyzers \u00b6 Application Lifecycle Analyzer Messaging Center Analyzer Dependency Service Analyzer NavigationResult Handling Analyzer Xamarin.Essentials Usage Analyzer Dependency Injection Anti-Pattern Analyzer Various Analyzers for improper use of Magician Attributes Planned Analyzers \u00b6 Unregistered Services Detect Additional Bad Coding Practices Detect Common Client Id's hard coded Detect Additional Bad Practices with Prism's Container Detect Invalid ViewModel names (i.e. ViewViewModel) Detect Direct INavigationService references when using the Generated ViewModelBase Will there be more? \u00b6 Yes there will be more analyzers planned and implemented over time. If you have an issue that has caused you problems in the past, be sure to reach out in the Magician channel in Discord and let me know.","title":"About"},{"location":"analyzers/#magician-analyzers","text":"Perhaps one of the most powerful things you never knew you needed, and one of my all time favorite stories. Have you ever seen a resume where someone claimed to be an expert at Intellisense? We all rely on Intellisense to help us write better code and refactor code that could be a little better. Without a doubt Roslyn has made this a much better process for .NET Developers. The Magician ships with several Roslyn Analyzers to help power your Intellisense and light up some additional build warnings or errors to keep you on track. At this time the Analyzer suite is still in its infancy, and new analyzers and code refactoring will be introduced over time.","title":"Magician Analyzers"},{"location":"analyzers/#included-analyzers","text":"Application Lifecycle Analyzer Messaging Center Analyzer Dependency Service Analyzer NavigationResult Handling Analyzer Xamarin.Essentials Usage Analyzer Dependency Injection Anti-Pattern Analyzer Various Analyzers for improper use of Magician Attributes","title":"Included Analyzers"},{"location":"analyzers/#planned-analyzers","text":"Unregistered Services Detect Additional Bad Coding Practices Detect Common Client Id's hard coded Detect Additional Bad Practices with Prism's Container Detect Invalid ViewModel names (i.e. ViewViewModel) Detect Direct INavigationService references when using the Generated ViewModelBase","title":"Planned Analyzers"},{"location":"analyzers/#will-there-be-more","text":"Yes there will be more analyzers planned and implemented over time. If you have an issue that has caused you problems in the past, be sure to reach out in the Magician channel in Discord and let me know.","title":"Will there be more?"},{"location":"code-gen/auto-initialization/","text":"Auto Initialization was a powerful feature previewed in Prism.Forms 7.2. There were a number of limitations though as this was ultimately powered by runtime Reflection, and of course was limited to only supporting Xamarin.Forms applications. How The Magician Does it Better! \u00b6 The Magician works at build time to generate the required Initialization and it doesn't care about whether you're working with a Forms, WPF, or Uno platform app. [AutoInitialize] public partial class ViewAViewModel : BindableBase { [Bindable] public string Message { get ; set ; } } Here we can keep our ViewModel nice and clean. We absolutely intend on having a Bindable Message property, but we don't need to add all of the boiler plate to check for it and set it. Instead we can simply add the AutoInitialize attribute to the ViewModel and the Magician will generate the initialization logic for us. Note How the Magician operates here is a little different depending on whether we are working with a ViewModel for a Region, Dialog or Page Navigation. In the event that you have already provided a method body for the Initialization method, the Magician will generate a AutoInitialize method. This method will then be invoked via IL Weaving from the correct initialization method.","title":"Auto Initialization"},{"location":"code-gen/auto-initialization/#how-the-magician-does-it-better","text":"The Magician works at build time to generate the required Initialization and it doesn't care about whether you're working with a Forms, WPF, or Uno platform app. [AutoInitialize] public partial class ViewAViewModel : BindableBase { [Bindable] public string Message { get ; set ; } } Here we can keep our ViewModel nice and clean. We absolutely intend on having a Bindable Message property, but we don't need to add all of the boiler plate to check for it and set it. Instead we can simply add the AutoInitialize attribute to the ViewModel and the Magician will generate the initialization logic for us. Note How the Magician operates here is a little different depending on whether we are working with a ViewModel for a Region, Dialog or Page Navigation. In the event that you have already provided a method body for the Initialization method, the Magician will generate a AutoInitialize method. This method will then be invoked via IL Weaving from the correct initialization method.","title":"How The Magician Does it Better!"},{"location":"code-gen/dialogs/","text":"Coming Soon...","title":"Dialogs"},{"location":"code-gen/reactiveui/","text":"ReactiveUI is an extremely popular library that further helps developers write MVVM applications using the Reactive Programming model. There are often questions about whether you should use ReactiveUI or _ ___. The simple fact of the matter is that when building a Prism Application, this is not an or, but rather an AND. ReactiveUI and Prism work very well together. In these cases you may find yourself using ReactiveObject as a base class rather than Prism's BindableBase. The Magician fully understands how to use ReactiveUI. Important Do NOT use ReactiveUI.Fody with the Magician. The Magician replaces all functionality from that weaver package, including Reactive properties, and ObservableAsHelper's. Reactive Properties \u00b6 When working with normal Bindable properties using BindableBase we use the Bindable attribute on the properties we want to have the Magician update for us. public class SomeViewModel : BindableBase { [Bindable] public string Message { get ; set ; } } However when using ReactiveObject as our base class the getter and setter are a little different and ultimately the Bindable paradigm is the wrong terminology. To keep this clear the Bindable attribute used on properties within a class inheriting from ReactiveObject will generate an error. You should instead use the Reactive attribute on these properties. public class SomeViewModel : ReactiveObject { [Reactive] public string Message { get ; set ; } } ObservableAsPropertyHelper \u00b6 ReactiveUI has a fantastic helper type known as ObservableAsPropertyHelper<T>. This helper class enables us to take at times complex Observables and return simple properties that we will use to bind to, while at the same time helping us to raise the Property Changed event. So what does this look like? public class ViewAViewModel : ReactiveObject { public ViewAViewModel ( IConnectivity connectivity ) { connectivity . WhenInternetStatusChanged () . ToProperty ( this , nameof ( IsOnline ), out _isOnlineHelper , true ); } private ObservableAsPropertyHelper < bool > _isOnlineHelper ; public bool IsOnline => _isOnlineHelper ?. Value ?? false ; } Here again the Magician uses a combination of things to help you out and keep you code clear on intent. public class ViewAViewModel : ReactiveObject { public ViewAViewModel ( IConnectivity connectivity ) { connectivity . WhenInternetStatusChanged () . ToProperty ( this , nameof ( IsOnline ), out _isOnlineHelper , true ); } [ObservableAsProperty] public bool IsOnline { get ; } } Ultimately the Magician has no clue what business logic you require to create the ObservableAsPropertyHelper, however we can again use CodeGeneration to create the private field and IL weaving to update the getter here.","title":"ReactiveUI"},{"location":"code-gen/reactiveui/#reactive-properties","text":"When working with normal Bindable properties using BindableBase we use the Bindable attribute on the properties we want to have the Magician update for us. public class SomeViewModel : BindableBase { [Bindable] public string Message { get ; set ; } } However when using ReactiveObject as our base class the getter and setter are a little different and ultimately the Bindable paradigm is the wrong terminology. To keep this clear the Bindable attribute used on properties within a class inheriting from ReactiveObject will generate an error. You should instead use the Reactive attribute on these properties. public class SomeViewModel : ReactiveObject { [Reactive] public string Message { get ; set ; } }","title":"Reactive Properties"},{"location":"code-gen/reactiveui/#observableaspropertyhelper","text":"ReactiveUI has a fantastic helper type known as ObservableAsPropertyHelper<T>. This helper class enables us to take at times complex Observables and return simple properties that we will use to bind to, while at the same time helping us to raise the Property Changed event. So what does this look like? public class ViewAViewModel : ReactiveObject { public ViewAViewModel ( IConnectivity connectivity ) { connectivity . WhenInternetStatusChanged () . ToProperty ( this , nameof ( IsOnline ), out _isOnlineHelper , true ); } private ObservableAsPropertyHelper < bool > _isOnlineHelper ; public bool IsOnline => _isOnlineHelper ?. Value ?? false ; } Here again the Magician uses a combination of things to help you out and keep you code clear on intent. public class ViewAViewModel : ReactiveObject { public ViewAViewModel ( IConnectivity connectivity ) { connectivity . WhenInternetStatusChanged () . ToProperty ( this , nameof ( IsOnline ), out _isOnlineHelper , true ); } [ObservableAsProperty] public bool IsOnline { get ; } } Ultimately the Magician has no clue what business logic you require to create the ObservableAsPropertyHelper, however we can again use CodeGeneration to create the private field and IL weaving to update the getter here.","title":"ObservableAsPropertyHelper"},{"location":"code-gen/service-registration/","text":"Service Registration can get really tedious. You have an interface definition, with one or more implementations. Maybe you need to register them in your Module or Application or perhaps you're using Shiny and need to register it in your Startup. The Magician uses a pattern similar to MEF in which a Registration attribute is added to the service implementation. There is an attribute matching each of Prism 8's registration APIs. For example let's say that we had the following services: public interface IBackendOptions { string Uri { get ; } string ClientId { get ; } } public interface IApiClient { // your API here... } We know that we'll be using these services in our app, typically we might have something like: protected override void RegisterTypes ( IContainerRegistry containerRegistry ) { containerRegistry . RegisterSingleton < IBackendOptions , BackendOptions >(); containerRegistry . Register < IApiClient , MyApiClient >(); } While you can continue to do that with services manually, with the Magician you can now instead decorate your service implementations like: [RegisterSingleton] public class BackendOptions : IBackendOptions { } [Register] public class MyApiClient : IApiClient { } As you might expect, the Magician will generate the code that you would have written above. This however helps to ensure that as you are working on your service implementation you will always be able to see at a glance that it is registered which additionally helps as other developers on your team work on the code later on. Note Scoped Services are currently not supported. If you have a good use case for why you really need a Scoped Service you should discuss this in Discord, and it could be added. At the current time, it's my belief that only in the case of the Prism INavigationService in Prism.Forms is there truly a good case for Scoped services in a Prism application. Multiple Interfaces \u00b6 There are times in which you may find yourself implementing multiple services. As example we may implement our IApiClient, and IDisposable on MyApiClient. We have no real way of knowing however whether you want MyApiClient to be registered for IApiClient or IDisposable. In this particular case you can specify the service type like: [Register(typeof(IApiClient))] public class MyApiClient : IApiClient , IDisposable { // your code here } Registering Multiple Services for a Single Implementation \u00b6 Sometimes you may find a need to have multiple smaller service definitions. As an example let's say that we're building an modular application. We might have an Authentication Module with an Authentication Service that handles getting the authentication token we will use to work with our API, and ultimately invalidating our session / token when the user signs out. We may however want to expose the Sign Out functionality in a common interface that can be shared between various modules in our application. In this case we might end up with something like: public interface IUserSessionService { Task SignOutAsync (); } public interface IAuthenticationService { Task < string > SignInAsync (); } public class AuthenticationService : IAuthenticationService , IUserSessionService { // your code here } In this case we can provide the AuthenticationService with the RegisterMany or RegisterManySingleton attribute depending on whether we expect a new instance or a single instance of the Authentication Service to be maintained. [RegisterManySingleton] public class AuthenticationService : IAuthenticationService , IUserSessionService { // your code here } Note When using RegisterManySingleton you will get a single instance of the Service implementation that will be used across all services. It will not be a single instance per service. Important If you have an interface such as IDisposable that should not be implemented be sure to pass the service types in the constructor of the attribute See Also \u00b6 Automatic View Registration","title":"Service Registration"},{"location":"code-gen/service-registration/#multiple-interfaces","text":"There are times in which you may find yourself implementing multiple services. As example we may implement our IApiClient, and IDisposable on MyApiClient. We have no real way of knowing however whether you want MyApiClient to be registered for IApiClient or IDisposable. In this particular case you can specify the service type like: [Register(typeof(IApiClient))] public class MyApiClient : IApiClient , IDisposable { // your code here }","title":"Multiple Interfaces"},{"location":"code-gen/service-registration/#registering-multiple-services-for-a-single-implementation","text":"Sometimes you may find a need to have multiple smaller service definitions. As an example let's say that we're building an modular application. We might have an Authentication Module with an Authentication Service that handles getting the authentication token we will use to work with our API, and ultimately invalidating our session / token when the user signs out. We may however want to expose the Sign Out functionality in a common interface that can be shared between various modules in our application. In this case we might end up with something like: public interface IUserSessionService { Task SignOutAsync (); } public interface IAuthenticationService { Task < string > SignInAsync (); } public class AuthenticationService : IAuthenticationService , IUserSessionService { // your code here } In this case we can provide the AuthenticationService with the RegisterMany or RegisterManySingleton attribute depending on whether we expect a new instance or a single instance of the Authentication Service to be maintained. [RegisterManySingleton] public class AuthenticationService : IAuthenticationService , IUserSessionService { // your code here } Note When using RegisterManySingleton you will get a single instance of the Service implementation that will be used across all services. It will not be a single instance per service. Important If you have an interface such as IDisposable that should not be implemented be sure to pass the service types in the constructor of the attribute","title":"Registering Multiple Services for a Single Implementation"},{"location":"code-gen/service-registration/#see-also","text":"Automatic View Registration","title":"See Also"},{"location":"code-gen/view-bindable-props/","text":"Important This feature is still in preview as the IL Weaving piece has not yet been completed It's not at all uncommon when developing custom components to be working with the Application Framework's View types, and need to add a BindableProperty / DependencyProperty. These properties tend to be very verbose, not very type friendly, static, and a lot of typing. The Magician aims to make these tasks a little easier by allowing you to write convention based code that simplifies what your intent is. For this sample we'll look at a Xamarin.Forms Bindable Property, but WPF/Uno Platform Dependency Properties will work the same way. Let's say that you're building a reusable UserProfileComponent and it will have a FirstName and LastName property which will bind to different labels. What your real intent here is that you have two properties, so why clutter it up? public partial class UserProfileComponent : ContentView { [BindableProperty] public string FirstName { get ; set ; } [BindableProperty] public string LastName { get ; set ; } } Note When working with a WPF / Uno Platform project, use the DependencyProperty attribute instead. The BindableProperty attribute is ignored on those platforms and the DependencyProperty attribute is ignored in Xamarin.Forms projects. Important Always be sure to make any class partial when using the Magician otherwise it will fail the build when it generates additional code. The Magician will first CodeGen our BindableProperties like: public partial class UserProfileComponent : ContentView { public static readonly BindableProperty FirstNameProperty = BindableProperty . Create ( \"FirstName\" , typeof ( string ), typeof ( UserProfileComponent ), null ); public static readonly BindableProperty FirstNameProperty = BindableProperty . Create ( \"LastName\" , typeof ( string ), typeof ( UserProfileComponent ), null ); } Next the Magician will use IL weaving to change our getter and setter to: public partial class UserProfileComponent : ContentView { public string FirstName { get => ( string ) GetValue ( FirstNameProperty ); set => SetValue ( FirstNameProperty , value ); } } Warning The IL weaving feature is still not complete. Default Values \u00b6 When adding the BindableProperty or DependencyProperty attribute you can pass a default value in the constructor of the attribute. This value will be used as the default value in the generated BindableProperty or DependencyProperty. [BindableProperty(\"Dan\")] public string FirstName { get ; set ; } [BindableProperty(\"Siegel\")] public string LastName { get ; set ; } Handling events \u00b6 Handling Changed events with Bindable or Dependency Properties can be quite infuriating as you're working with the least common denominator rather than working with a strongly typed API. For example you may normally write a handler like: private static void OnFirstNameChanged ( BindableObject bindable , object oldValue , object newValue ) { // Your code here } With the Magician you have both flexibility and the ability to continue writing the same horrible method handlers, or you can write more intelligent handlers like: private static void OnFirstNameChanged ( UserProfileComponent component , string oldValue , string newValue ) { // Your code here } Granted that's better but still not really ideal in my opinion, so the Magician has you covered as you can also write your handlers like: private void OnFirstNameChanged ( string oldValue , string newValue ) { // Your code here } Or you can keep it really simple like: private void OnFirstNameChanged () { // Your code here } Customizing Event Handler Behavior \u00b6 Let's say that you have a 3rd property for the DisplayName and this will need to be updated whenever either the FirstName or LastName are updated. We can easily achieve this with the Magician: public partial class UserProfileComponent : ContentView { [BindableProperty] public string DisplayName { get ; set ; } [BindableProperty(onChanged: nameof(UpdateDisplayName))] public string FirstName { get ; set ; } [BindableProperty(onChanged: nameof(UpdateDisplayName))] public string LastName { get ; set ; } private void UpdateDisplayName () { string name = null ; if (! string . IsNullOrEmpty ( FirstName )) { name = FirstName ; if (! string . IsNullOrEmpty ( LastName )) { name += $ \" {LastName[0]}.\" ; } } else if (! string . IsNullOrEmpty ( LastName )) { name = $ \"Mr. {LastName}\" ; } DisplayName = name ; } }","title":"Bindable/Dependency Props"},{"location":"code-gen/view-bindable-props/#default-values","text":"When adding the BindableProperty or DependencyProperty attribute you can pass a default value in the constructor of the attribute. This value will be used as the default value in the generated BindableProperty or DependencyProperty. [BindableProperty(\"Dan\")] public string FirstName { get ; set ; } [BindableProperty(\"Siegel\")] public string LastName { get ; set ; }","title":"Default Values"},{"location":"code-gen/view-bindable-props/#handling-events","text":"Handling Changed events with Bindable or Dependency Properties can be quite infuriating as you're working with the least common denominator rather than working with a strongly typed API. For example you may normally write a handler like: private static void OnFirstNameChanged ( BindableObject bindable , object oldValue , object newValue ) { // Your code here } With the Magician you have both flexibility and the ability to continue writing the same horrible method handlers, or you can write more intelligent handlers like: private static void OnFirstNameChanged ( UserProfileComponent component , string oldValue , string newValue ) { // Your code here } Granted that's better but still not really ideal in my opinion, so the Magician has you covered as you can also write your handlers like: private void OnFirstNameChanged ( string oldValue , string newValue ) { // Your code here } Or you can keep it really simple like: private void OnFirstNameChanged () { // Your code here }","title":"Handling events"},{"location":"code-gen/view-bindable-props/#customizing-event-handler-behavior","text":"Let's say that you have a 3rd property for the DisplayName and this will need to be updated whenever either the FirstName or LastName are updated. We can easily achieve this with the Magician: public partial class UserProfileComponent : ContentView { [BindableProperty] public string DisplayName { get ; set ; } [BindableProperty(onChanged: nameof(UpdateDisplayName))] public string FirstName { get ; set ; } [BindableProperty(onChanged: nameof(UpdateDisplayName))] public string LastName { get ; set ; } private void UpdateDisplayName () { string name = null ; if (! string . IsNullOrEmpty ( FirstName )) { name = FirstName ; if (! string . IsNullOrEmpty ( LastName )) { name += $ \" {LastName[0]}.\" ; } } else if (! string . IsNullOrEmpty ( LastName )) { name = $ \"Mr. {LastName}\" ; } DisplayName = name ; } }","title":"Customizing Event Handler Behavior"},{"location":"code-gen/view-registration/","text":"Automatic View Registration couldn't be easier and has some distinct performance advantages over the built in Prism Automatic View registration for Prism.Forms. The Magician's Automatic View Registration: works on ALL platforms including WPF & Uno Platform bypasses runtime reflection with compile time generated code registers both the View & ViewModel extends the standard Prism ViewModelLocator defaults to find ViewModels with other common conventions Sounds great right? But how do you use it? Simply add the AutoRegisterViews attribute to your Module, PrismApplication, or PrismBootstrapper (WPF only) as shown below: [AutoRegisterViews] public partial class App : PrismApplication { // your code here } ViewModel Location \u00b6 By Default Prism's ViewModel Locator convention looks for the ViewModel in the ViewModels namespace with a ViewModel suffix like: ViewA -> ViewAViewModel SomeView -> SomeViewModel The Magician is a little smarter where we will also look for SomePage -> SomeViewModel In addition to that the Magician will check in both the Views and ViewModel's namespaces incase you prefer to keep your ViewModel and View next to each other in a more logical construct. What is a View \u00b6 This is actually a little more complex than you might think when it comes to automatic View discovery for Navigation. In the case of WPF or Uno platform, and in the event that you are using Regions for Prism.Forms your View is realistically derived from a type that could make it a custom or composite control. As a filter the Magician will evaluate all appropriate types within the Dialogs, Views, and Pages namespaces. Note The Magician will not register any View types that are abstract, and will automatically register the Xamarin.Forms TabbedPage & NavigationPage Customized View Naming \u00b6 Let's assume that you have a View name like UserProfilePage . There are 4 common conventions that developers tend to use. UserProfilePage UserProfile userProfilePage userProfile Depending on your preference, in your application project add the NameFormatProvider attribute and pass in the preferred Style. If you do not do this your application will continue to use the default Type name. [assembly: NameFormatProvider(NameFormatProviderStyle.CamelCaseNoPageSuffix)] Region, Dialog, & Navigation Keys \u00b6 As the Magician works to register each View it finds for Page Navigation, Region Navigation or as a Dialog, it will collect a mapping of what each name should be along with each type. When it's all done you will get up to 3 new classes generated in the .Navigation namespace of your project. public partial class NavigationKeys { public const string HomePage = \"home\" ; public const string LoginPage = \"login\" ; } public partial class DialogKeys { public const string AlertDialog = \"alert\" ; } With a generated keys class you can now directly reference what you need in an MVVM friendly way without violating the MVVM pattern with: _regionManager . RequestNavigate ( nameof ( ViewA )); Additionally the Magician will evaluate your XAML and construct a list of the various Regions within your WPF, Uno Platform, or Xamarin.Forms application, and will create an additional class like: public partial class RegionNames { public const string ContentRegion = \"ContentRegion\" ; }","title":"View Registration"},{"location":"code-gen/view-registration/#viewmodel-location","text":"By Default Prism's ViewModel Locator convention looks for the ViewModel in the ViewModels namespace with a ViewModel suffix like: ViewA -> ViewAViewModel SomeView -> SomeViewModel The Magician is a little smarter where we will also look for SomePage -> SomeViewModel In addition to that the Magician will check in both the Views and ViewModel's namespaces incase you prefer to keep your ViewModel and View next to each other in a more logical construct.","title":"ViewModel Location"},{"location":"code-gen/view-registration/#what-is-a-view","text":"This is actually a little more complex than you might think when it comes to automatic View discovery for Navigation. In the case of WPF or Uno platform, and in the event that you are using Regions for Prism.Forms your View is realistically derived from a type that could make it a custom or composite control. As a filter the Magician will evaluate all appropriate types within the Dialogs, Views, and Pages namespaces. Note The Magician will not register any View types that are abstract, and will automatically register the Xamarin.Forms TabbedPage & NavigationPage","title":"What is a View"},{"location":"code-gen/view-registration/#customized-view-naming","text":"Let's assume that you have a View name like UserProfilePage . There are 4 common conventions that developers tend to use. UserProfilePage UserProfile userProfilePage userProfile Depending on your preference, in your application project add the NameFormatProvider attribute and pass in the preferred Style. If you do not do this your application will continue to use the default Type name. [assembly: NameFormatProvider(NameFormatProviderStyle.CamelCaseNoPageSuffix)]","title":"Customized View Naming"},{"location":"code-gen/view-registration/#region-dialog-navigation-keys","text":"As the Magician works to register each View it finds for Page Navigation, Region Navigation or as a Dialog, it will collect a mapping of what each name should be along with each type. When it's all done you will get up to 3 new classes generated in the .Navigation namespace of your project. public partial class NavigationKeys { public const string HomePage = \"home\" ; public const string LoginPage = \"login\" ; } public partial class DialogKeys { public const string AlertDialog = \"alert\" ; } With a generated keys class you can now directly reference what you need in an MVVM friendly way without violating the MVVM pattern with: _regionManager . RequestNavigate ( nameof ( ViewA )); Additionally the Magician will evaluate your XAML and construct a list of the various Regions within your WPF, Uno Platform, or Xamarin.Forms application, and will create an additional class like: public partial class RegionNames { public const string ContentRegion = \"ContentRegion\" ; }","title":"Region, Dialog, &amp; Navigation Keys"},{"location":"code-gen/viewmodelbase/","text":"The Magician will help write you a complete base ViewModel customized to your current application references. This means that if you have a reference to System.Reactive through libraries like Shiny or ReactiveUI then it will automatically give you some reactive benefits like the Composite Disposable that will be called by IDestructible for you. See Also \u00b6 ReactiveUI","title":"ViewModelBase"},{"location":"code-gen/viewmodelbase/#see-also","text":"ReactiveUI","title":"See Also"}]}